"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventManager = void 0;
/**
 * 🎮 Event Manager Module
 */
const events_1 = __importDefault(require("events"));
const types_1 = require("../../types");
class EventManager {
    constructor(subscribe) {
        this.subscribe = subscribe;
        this.emitter = new events_1.default();
        this.handlers = new Map();
    }
    // Convenience handlers for common event types
    onTranscription(handler) {
        return this.addHandler(types_1.StreamType.TRANSCRIPTION, handler);
    }
    onHeadPosition(handler) {
        return this.addHandler(types_1.StreamType.HEAD_POSITION, handler);
    }
    onButtonPress(handler) {
        return this.addHandler(types_1.StreamType.BUTTON_PRESS, handler);
    }
    onPhoneNotifications(handler) {
        return this.addHandler(types_1.StreamType.PHONE_NOTIFICATION, handler);
    }
    onGlassesBattery(handler) {
        return this.addHandler(types_1.StreamType.GLASSES_BATTERY_UPDATE, handler);
    }
    onPhoneBattery(handler) {
        return this.addHandler(types_1.StreamType.PHONE_BATTERY_UPDATE, handler);
    }
    onVoiceActivity(handler) {
        return this.addHandler(types_1.StreamType.VAD, handler);
    }
    onLocation(handler) {
        return this.addHandler(types_1.StreamType.LOCATION_UPDATE, handler);
    }
    /**
     * 🎤 Listen for audio chunk data
     * @param handler - Function to handle audio chunks
     * @returns Cleanup function to remove the handler
     */
    onAudioChunk(handler) {
        return this.addHandler(types_1.StreamType.AUDIO_CHUNK, handler);
    }
    // System event handlers
    onConnected(handler) {
        this.emitter.on('connected', handler);
        return () => this.emitter.off('connected', handler);
    }
    onDisconnected(handler) {
        this.emitter.on('disconnected', handler);
        return () => this.emitter.off('disconnected', handler);
    }
    onError(handler) {
        this.emitter.on('error', handler);
        return () => this.emitter.off('error', handler);
    }
    onSettingsUpdate(handler) {
        this.emitter.on('settings_update', handler);
        return () => this.emitter.off('settings_update', handler);
    }
    /**
     * 🔄 Generic event handler
     *
     * Use this for stream types without specific handler methods
     */
    on(type, handler) {
        return this.addHandler(type, handler);
    }
    /**
     * ➕ Add an event handler and subscribe if needed
     */
    addHandler(type, handler) {
        const handlers = this.handlers.get(type) ?? new Set();
        if (handlers.size === 0) {
            this.handlers.set(type, handlers);
            this.subscribe(type);
        }
        handlers.add(handler);
        return () => this.removeHandler(type, handler);
    }
    /**
     * ➖ Remove an event handler
     */
    removeHandler(type, handler) {
        const handlers = this.handlers.get(type);
        if (!handlers)
            return;
        handlers.delete(handler);
        if (handlers.size === 0) {
            this.handlers.delete(type);
        }
    }
    /**
     * 📡 Emit an event to all registered handlers
     */
    emit(event, data) {
        // Emit to EventEmitter handlers (system events)
        this.emitter.emit(event, data);
        // Emit to stream handlers if applicable
        const handlers = this.handlers.get(event);
        if (handlers) {
            handlers.forEach(handler => {
                handler(data);
            });
        }
    }
}
exports.EventManager = EventManager;
