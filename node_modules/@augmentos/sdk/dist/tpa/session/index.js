"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TpaSession = void 0;
/**
 * 🎯 TPA Session Module
 *
 * Manages an active Third Party App session with AugmentOS Cloud.
 * Handles real-time communication, event subscriptions, and display management.
 */
const ws_1 = __importDefault(require("ws"));
const events_1 = require("./events");
const layouts_1 = require("./layouts");
const types_1 = require("../../types");
/**
 * 🚀 TPA Session Implementation
 *
 * Manages a live connection between your TPA and AugmentOS Cloud.
 * Provides interfaces for:
 * - 🎮 Event handling (transcription, head position, etc.)
 * - 📱 Display management in AR view
 * - 🔌 Connection lifecycle
 * - 🔄 Automatic reconnection
 *
 * @example
 * ```typescript
 * const session = new TpaSession({
 *   packageName: 'org.example.myapp',
 *   apiKey: 'your_api_key'
 * });
 *
 * // Handle events
 * session.onTranscription((data) => {
 *   session.layouts.showTextWall(data.text);
 * });
 *
 * // Connect to cloud
 * await session.connect('session_123');
 * ```
 */
class TpaSession {
    constructor(config) {
        this.config = config;
        /** WebSocket connection to AugmentOS Cloud */
        this.ws = null;
        /** Current session identifier */
        this.sessionId = null;
        /** Number of reconnection attempts made */
        this.reconnectAttempts = 0;
        /** Active event subscriptions */
        this.subscriptions = new Set();
        this.config = {
            augmentOSWebsocketUrl: `ws://dev.augmentos.org/tpa-ws`,
            autoReconnect: false,
            maxReconnectAttempts: 0,
            reconnectDelay: 1000,
            ...config
        };
        this.events = new events_1.EventManager(this.subscribe.bind(this));
        this.layouts = new layouts_1.LayoutManager(config.packageName, this.send.bind(this));
    }
    // =====================================
    // 🎮 Direct Event Handling Interface
    // =====================================
    /**
     * 🎤 Listen for speech transcription events
     * @param handler - Function to handle transcription data
     * @returns Cleanup function to remove the handler
     */
    onTranscription(handler) {
        return this.events.onTranscription(handler);
    }
    /**
     * 👤 Listen for head position changes
     * @param handler - Function to handle head position updates
     * @returns Cleanup function to remove the handler
     */
    onHeadPosition(handler) {
        return this.events.onHeadPosition(handler);
    }
    /**
     * 🔘 Listen for hardware button press events
     * @param handler - Function to handle button events
     * @returns Cleanup function to remove the handler
     */
    onButtonPress(handler) {
        return this.events.onButtonPress(handler);
    }
    /**
     * 📱 Listen for phone notification events
     * @param handler - Function to handle notifications
     * @returns Cleanup function to remove the handler
     */
    onPhoneNotifications(handler) {
        return this.events.onPhoneNotifications(handler);
    }
    // =====================================
    // 📡 Pub/Sub Interface
    // =====================================
    /**
     * 📬 Subscribe to a specific event stream
     * @param type - Type of event to subscribe to
     */
    subscribe(type) {
        this.subscriptions.add(type);
        if (this.ws?.readyState === ws_1.default.OPEN) {
            this.updateSubscriptions();
        }
    }
    /**
     * 🎯 Generic event listener (pub/sub style)
     * @param event - Event name to listen for
     * @param handler - Event handler function
     */
    on(event, handler) {
        return this.events.on(event, handler);
    }
    // =====================================
    // 🔌 Connection Management
    // =====================================
    /**
     * 🚀 Connect to AugmentOS Cloud
     * @param sessionId - Unique session identifier
     * @returns Promise that resolves when connected
     */
    async connect(sessionId) {
        this.sessionId = sessionId;
        return new Promise((resolve, reject) => {
            try {
                this.ws = new ws_1.default(this.config.augmentOSWebsocketUrl);
                this.ws.on('open', () => {
                    this.sendConnectionInit();
                });
                this.ws.on('message', (data) => {
                    try {
                        const message = JSON.parse(data.toString());
                        this.handleMessage(message);
                    }
                    catch (error) {
                        this.events.emit('error', new Error('Failed to parse message'));
                    }
                });
                this.ws.on('close', () => {
                    this.events.emit('disconnected', 'Connection closed');
                    this.handleReconnection();
                });
                this.ws.on('error', (error) => {
                    this.events.emit('error', error);
                });
                this.events.onConnected(() => resolve());
                // Connection timeout after 5 seconds
                setTimeout(() => {
                    reject(new Error('Connection timeout'));
                }, 5000);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    /**
     * 👋 Disconnect from AugmentOS Cloud
     */
    disconnect() {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
        this.sessionId = null;
        this.subscriptions.clear();
    }
    // =====================================
    // 🔧 Private Methods
    // =====================================
    /**
     * 📨 Handle incoming messages from cloud
     */
    handleMessage(message) {
        // Handle binary data (audio or video)
        if (message instanceof ArrayBuffer) {
            // Determine which type of binary data we're receiving
            // This would typically be based on the active subscriptions
            // or message metadata, but for now let's default to audio chunks
            // Create the appropriate binary message structure
            if (this.subscriptions.has(types_1.StreamType.AUDIO_CHUNK)) {
                const audioChunk = {
                    type: types_1.StreamType.AUDIO_CHUNK,
                    timestamp: new Date(),
                    arrayBuffer: message,
                    sampleRate: 16000, // Default values that could be set by the server
                    // data: message,
                    // channels: 1,
                    // format: 'pcm'
                };
                // Emit to subscribers
                this.events.emit(types_1.StreamType.AUDIO_CHUNK, audioChunk);
            }
            return;
        }
        // Using type guards to determine message type
        if ((0, types_1.isTpaConnectionAck)(message)) {
            this.events.emit('connected', message.settings);
            this.updateSubscriptions();
        }
        else if ((0, types_1.isTpaConnectionError)(message)) {
            this.events.emit('error', new Error(message.message));
        }
        else if ((0, types_1.isDataStream)(message)) {
            this.events.emit(message.streamType, message.data);
        }
        else if ((0, types_1.isSettingsUpdate)(message)) {
            this.events.emit('settings_update', message.settings);
        }
        else if ((0, types_1.isAppStopped)(message)) {
            this.events.emit('disconnected', `App stopped: ${message.reason}`);
        }
    }
    /**
     * 🔐 Send connection initialization message
     */
    sendConnectionInit() {
        const message = {
            type: types_1.TpaToCloudMessageType.CONNECTION_INIT,
            sessionId: this.sessionId,
            packageName: this.config.packageName,
            apiKey: this.config.apiKey,
            timestamp: new Date()
        };
        this.send(message);
    }
    /**
     * 📝 Update subscription list with cloud
     */
    updateSubscriptions() {
        const message = {
            type: types_1.TpaToCloudMessageType.SUBSCRIPTION_UPDATE,
            packageName: this.config.packageName,
            subscriptions: Array.from(this.subscriptions),
            sessionId: this.sessionId,
            timestamp: new Date()
        };
        this.send(message);
    }
    /**
     * 🔄 Handle reconnection with exponential backoff
     */
    async handleReconnection() {
        if (!this.config.autoReconnect ||
            !this.sessionId ||
            this.reconnectAttempts >= (this.config.maxReconnectAttempts || 5)) {
            return;
        }
        const delay = (this.config.reconnectDelay || 1000) * Math.pow(2, this.reconnectAttempts);
        this.reconnectAttempts++;
        await new Promise(resolve => setTimeout(resolve, delay));
        try {
            await this.connect(this.sessionId);
            this.reconnectAttempts = 0;
        }
        catch (error) {
            this.events.emit('error', new Error('Reconnection failed'));
        }
    }
    /**
     * 📤 Send message to cloud
     * @throws {Error} If WebSocket is not connected
     */
    send(message) {
        if (!this.ws || this.ws.readyState !== ws_1.default.OPEN) {
            throw new Error('WebSocket not connected');
        }
        this.ws.send(JSON.stringify(message));
    }
}
exports.TpaSession = TpaSession;
