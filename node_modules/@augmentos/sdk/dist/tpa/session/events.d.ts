/**
 * ðŸŽ® Event Manager Module
 */
import EventEmitter from 'events';
import { StreamType, AppSettings, WebSocketError, ButtonPress, HeadPosition, PhoneNotification, TranscriptionData, TranslationData, GlassesBatteryUpdate, PhoneBatteryUpdate, GlassesConnectionState, LocationUpdate, Vad, NotificationDismissed, AudioChunk } from '../../types';
/** ðŸŽ¯ Type-safe event handler function */
type Handler<T> = (data: T) => void;
/** ðŸ”„ System events not tied to streams */
interface SystemEvents {
    'connected': AppSettings | undefined;
    'disconnected': string;
    'error': WebSocketError | Error;
    'settings_update': AppSettings;
}
/** ðŸ“¡ All possible event types */
type EventType = StreamType | keyof SystemEvents;
/** ðŸ“¦ Map of stream types to their data types */
interface StreamDataTypes {
    [StreamType.BUTTON_PRESS]: ButtonPress;
    [StreamType.HEAD_POSITION]: HeadPosition;
    [StreamType.PHONE_NOTIFICATION]: PhoneNotification;
    [StreamType.TRANSCRIPTION]: TranscriptionData;
    [StreamType.TRANSLATION]: TranslationData;
    [StreamType.GLASSES_BATTERY_UPDATE]: GlassesBatteryUpdate;
    [StreamType.PHONE_BATTERY_UPDATE]: PhoneBatteryUpdate;
    [StreamType.GLASSES_CONNECTION_STATE]: GlassesConnectionState;
    [StreamType.LOCATION_UPDATE]: LocationUpdate;
    [StreamType.VAD]: Vad;
    [StreamType.NOTIFICATION_DISMISSED]: NotificationDismissed;
    [StreamType.AUDIO_CHUNK]: AudioChunk;
    [StreamType.VIDEO]: ArrayBuffer;
    [StreamType.OPEN_DASHBOARD]: never;
    [StreamType.START_APP]: never;
    [StreamType.STOP_APP]: never;
    [StreamType.ALL]: never;
    [StreamType.WILDCARD]: never;
}
/** ðŸ“¦ Data type for an event */
type EventData<T extends EventType> = T extends keyof StreamDataTypes ? StreamDataTypes[T] : T extends keyof SystemEvents ? SystemEvents[T] : never;
export declare class EventManager {
    private subscribe;
    private emitter;
    private handlers;
    constructor(subscribe: (type: StreamType) => void);
    onTranscription(handler: Handler<TranscriptionData>): () => void;
    onHeadPosition(handler: Handler<HeadPosition>): () => void;
    onButtonPress(handler: Handler<ButtonPress>): () => void;
    onPhoneNotifications(handler: Handler<PhoneNotification>): () => void;
    onGlassesBattery(handler: Handler<GlassesBatteryUpdate>): () => void;
    onPhoneBattery(handler: Handler<PhoneBatteryUpdate>): () => void;
    onVoiceActivity(handler: Handler<Vad>): () => void;
    onLocation(handler: Handler<LocationUpdate>): () => void;
    /**
     * ðŸŽ¤ Listen for audio chunk data
     * @param handler - Function to handle audio chunks
     * @returns Cleanup function to remove the handler
     */
    onAudioChunk(handler: Handler<AudioChunk>): () => void;
    onConnected(handler: Handler<SystemEvents['connected']>): () => EventEmitter<[never]>;
    onDisconnected(handler: Handler<SystemEvents['disconnected']>): () => EventEmitter<[never]>;
    onError(handler: Handler<SystemEvents['error']>): () => EventEmitter<[never]>;
    onSettingsUpdate(handler: Handler<SystemEvents['settings_update']>): () => EventEmitter<[never]>;
    /**
     * ðŸ”„ Generic event handler
     *
     * Use this for stream types without specific handler methods
     */
    on<T extends StreamType>(type: T, handler: Handler<StreamDataTypes[T]>): () => void;
    /**
     * âž• Add an event handler and subscribe if needed
     */
    private addHandler;
    /**
     * âž– Remove an event handler
     */
    private removeHandler;
    /**
     * ðŸ“¡ Emit an event to all registered handlers
     */
    emit<T extends EventType>(event: T, data: EventData<T>): void;
}
export {};
//# sourceMappingURL=events.d.ts.map